/*
7SSS: 7th Sea Stat System

THE CHARACTER SHEET:
	_d.sheet: on player, dbref of sheet
	d.player: on sheet, dbref of player - validate the two match

	<trait type>.<trait name>: <value>
	knack.<knack name>: <value>
	skill.<skill name>: <doesn't matter what goes here>

Maybe instead:
	special.skills: <list.of.skills.player.has>

USER-DEFINED FUNCTIONS:
		crumple( <test>, <character> ) --> trim( squish( )) it

================================================================================
== SHEET LOOKUP FUNCTIONS ======================================================

These are functions for the system to find and do certain magic on the player's sheet.


--------------------------------------------------------------------------------
-- Function: Is GM? ------------------------------------------------------------

Does the person have access to GM-level commands?

*/

&f.isgm? 7sss=cor( isstaff( %0 ), t( u( %0/_d.gm )))


/*
--------------------------------------------------------------------------------
-- Function: Find Player's Sheet -----------------------------------------------
*/

&f.sheet.find 7sss=
	localize( 
		case( 0, 
			t( setr( p, pmatch( %0 ))), #-1 Player Not Found, 
			t( setr( l, get( %qp/_d.sheet ))), #-2 Sheet Not Found, 
			strmatch( get( %ql/d.player ), qp ), 
			#-3 Sheet Is For Different Player, 
			%ql
		)
 	)


/*
================================================================================
== STATPATH LOOKUP FUNCTIONS ===================================================

As usual, the most important thing is when a character says 'forg' to know they mean the Forgery knack, when they say 'br' they mean the Brawn trait.

*/

@fo me=&d.dd 7sss=[num( 7sdd )]

&d.sort-order 7sss=trait skill bio arcana swordsman sorcery advantage wounds

/*

We might not use this, not yet sure. As knacks don't have their own data but
are instead pulled from the skills list.

*/

&d.statpath.sort-order 7sss=trait bio knack skill swordsman sorcery advantage


/*
--------------------------------------------------------------------------------
-- List of Knacks --------------------------------------------------------------

0: partial knack name, optional
1: which trait to look under, optional

returns: all knacks, all knacks of that trait, all knacks matching that name, or a mixture.

*/

&f.list.knacks 7sss=
	trim( 
		squish( 
			strcat( 
				u( f.knacks.skill, %0, %1 ), ., 
				u( f.knacks.swordsman, %0, %1 ), ., 
				u( f.knacks.sorcery, %0, %1 ), ., 
			)
		), 
		b, .
 )

// --

&f.list.knacks.skill 7sss=
	setunion( 
		crumple( 
			iter( 
				lattr( [u( d.7sdd )]/skill.%1* ), 
				graball( edit( get( [u( d.dd )]/%i0 ), |, . ), %0*, . ), 
				, .
			), 
			.
		), 
		, .
	)

// --

&f.list.knacks.swordsman 7sss=
	setunion( 
		crumple( 
			iter( 
				lattr( [u( d.7sdd )]/swordsman.%1* ), 
				graball( rest( get( [u( d.dd )]/%i0 ), | ), %0*, . ), 
				, .
			), 
			.
		), 
		, .
	)

/* (old version)

&f.list.knacks.sorcery 7sss=
	setunion( 
		graball( 
			iter( 
				if( t( %0 ), 
					grepi( [u( d.7sdd )], sorcery.%1*, %0 ), 
					lattr( [u( d.7sdd )]/sorcery.%1* )
				), 
				iter( %i0, u( [u( d.7sdd )]/%i0 ), , . ), , .
			), 
			%0*, 
			., 
			.
			), 
			, .
 		)

*/

&f.list.knacks.sorcery 7sss=
	setunion( 
		crumple( 
			iter( 
				lattr( [u( d.7sdd )]/sorcery.%1* ), 
				graball( get( [u( d.dd )]/%i0 ), %0*, . ), 
				, .
			), 
			.
		), 
		, .
	)


/*
--------------------------------------------------------------------------------
-- List of Skills, Swordsman Schools, Sorcery Heritage -------------------------

0: partial skill name, optional
returns: list.of.stat names

*/

&f.list.skill 7sss=u( f.list.skill-and-such, %0, skill )

&f.list.swordsman 7sss=u( f.list.skill-and-such, %0, swordsman )

&f.list.sorcery 7sss=u( f.list.skill-and-such, %0, sorcery )

&f.list.skill-and-such 7sss=
	iter( 
		lattr( [u( d.dd )]/%1.%0* ), 
		titlestr( edit( rest( %i0, . ), _, %b )), 
		, .
	)


/*
--------------------------------------------------------------------------------
-- Lookup Trait For Knack ------------------------------------------------------

List all the items that are associated with a specific Knack.

This takes one single exact knack name.  Use f.list.knacks.* to make partial name matches.

0: knack name, EXACT
returns: dd statpath for matching traits

*/

&f.lookup.trait-for-knack 7sss=
	trim( 
		iter( 
			skill swordsman sorcery, 
			lcstr( grepi( [u( d.dd )], %i0.*, %0 ))
		)
	)

// --

think [u( 7sss/f.lookup.trait-for-knack, u( 7sss/f.list.knacks.sorcery, fj ))]

// --> sorcery.laerdom


/*
--------------------------------------------------------------------------------
-- Lookup Type For Knack -------------------------------------------------------

The first part of 'trait for knack'

0: knack name

*/

&f.lookup.type-for-knack 7sss=first( u( f.lookup.trait-for-knack, %0 ), . )

// --

think [u( 7sss/f.lookup.type-for-knack, fj )]


/*
--------------------------------------------------------------------------------
-- Statpath: Knack -------------------------------------------------------------

Returns the knack as would be found on the sheet. ( DD -> Sheet )

0: knack name ( partial match ok )
1: trait type, if any ( skill, swordsman, sorcery )

i: instance, if entered
n: knack name, without instance

k: knack, as found
t: type, as found

*/

&f.statpath.knack 7sss=
	strcat( 
		setq( i, before( rest( %0, %( ), % ))), 
		setq( n, trim( before( %0, ( %qi )))), 

		setq( k, u( f.list.knacks, %qn*[if( t( %qi ), %b( %qi* ))] )), 
		if( 
			cand( t( %qi ), not( t( %qk ))), 
			setq( k, u( f.list.knacks, %qn*\\\\* ))
		), 

		setq( t, u( f.lookup.type-for-knack, %qk )), 

		case( 0, 
			t( %qk ), #-1 Knack Not Found, 
			eq( words( %qk, . ), 1 ), #-2 Multiple Knacks Found, 
			eq( words( %qt, . ), 1 ), #-3 Multiple Types Found for Knack, 
			lcstr( edit( knack.%qt.[edit( %qk, *, %qi )], %b, _ ))
		), 
	)

// --

think [u( 7sss/f.statpath.knack, fo( thing ))]
// --> knack.sorcery.form_( thing )

think [u( 7sss/f.statpath.knack, f( f ))]
// --> knack.swordsman.feint_( fencing )


/*
--------------------------------------------------------------------------------
-- Statpath: Trait -------------------------------------------------------------

While it may be true that all other stats are stored in an extremely simple <type>.<name> format, both on the sheet and data dictionary, why have a 'statpath trait' lookup?

1 ) Rolling is Trait + Knack.  No other stat is involved.
2 ) Consistency.  We have a statpath for knacks, we might as well have statpath everything else.

*/

&f.statpath.trait 7sss=
	strcat( 
		setq( t, lattr( [u( d.dd )]/trait.%0* )), 

		case( 0, 
			t( %qt ), #-1 Trait Not Found, 
			eq( words( %qt ), 1 ), #-2 Multiple Traits Found, 
			lcstr( %qt )
		)
	)

think u( 7sss/f.statpath.trait, fin )



/*
--------------------------------------------------------------------------------
-- Statpath: First -------------------------------------------------------------

That is, any but knacks.  Returns the first match on the sort order, regardless of how many are returned.  We'll error on searching for <null>.

0: stat name
1: type, optional

*/

&f.statpath.first 7sss=
	strcat( 
		setq( a, 
			if( 
				t( %1 ), lattr( [u( d.dd )]/%1.%0* ), 
				iter( u( d.sort-order ), 
					lattr( [u( d.dd )]/%i0.%0* )
				)
			)
		), 

		case( 0, 
			comp( %0, ), #-1 Stat Name Not Passed, 
			t( %qa ), #-1 No Stats Found, 
			lcstr( first( %qa ))
		), 
	)

// --

think u( 7sss/f.statpath.first, g )
// --> bio.guilder

think u( 7sss/f.statpath.first, gl )
// --> sorcery.glamour

think u( 7sss/f.statpath.first, g, sorcery )
// --> sorcery.glamour


/*
--------------------------------------------------------------------------------
-- Statpath: Any ---------------------------------------------------------------

Finally, we should return the statpath without knowing anything about what's passed.

0: stat name
1: stat type, optional

(not sure why we use 'localize' here and not in the other stapath functions)

*/

&f.statpath.any 7sss=
	localize( strcat( 
			setq( m, ), 

			case( 1, 
// .. "stat type" passed and matches a sort-order type
				t( match( u( d.sort-order ), %1 )), 
				u( f.statpath.first, %0, %1 ), 

// .. "stat type" passed and is probably "knack"
				strmatch( %1, k* ), 
				u( f.statpath.knack, %0 ), 

// .. try to find others before 'knack'.
				t( setr( m, u( f.statpath.first, %0 ))), 
				%qm, 

// .. last ditch effort, find the 'knack'
				u( f.statpath.knack, %0 )
			), 
 	))

// --

think u( 7sss/f.statpath.any, g )
think u( 7sss/f.statpath.any, g, sorcery )
think u( 7sss/f.statpath.any, f( f ))


/*
================================================================================
== User-Defined Function: Get Stat =============================================

	getstat( <player>/<stat>[, <type>] )

uses: pmatch+

qp: player dbref
qs: stat
qf: sheet dbref, or error message

*/

&ufunc.getstat 7sss=
	strcat( 
		setq( p, first( %0, / )), 
		setq( s, rest( %0, / )), 
		setq( p, pmatch( %qp )), 
		setq( f, u( f.sheet.find, %qp )), 

		case( 0, 
// .. errors
			t( %qp ), #-1 Player Not Found, 
			or( isstaff( %@ ), u( f.isgm?, %qp ), strmatch( %qp, %@ )), 
			#-1 GM or Self Only, 
			t( %qf ), %qf, 

			u( f.getstat.workhorse, %qp %qs, %qf, %1 )
		), 
	)


/*
--------------------------------------------------------------------------------
-- Function: Get Stat, Workhorse -----------------------------------------------

Grab the statpath.  get( <player>/_<statpath> ).  That's it.

Does not account for "default" stats yet.

--

0: player dbref
1: stat name (unchecked)
2: sheet dbref
3: stat type (unchecked)

qs: matched statpath

*/

&f.getstat.workhorse 7sss=
	localize( strcat( 
		setq( s, u( f.statpath.any, %1, %3 )), 

		case( 0, 
			t( %qs ), %qs, 
			get( %0/_%qs )
		), 
 ))

// ***** TEST LATER!! ******
// (note, this line was written some 5 years ago)


/*
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=

OLDER SYSTEM:


@create 7SR: 7th Sea Stat Roller

`roll <unkept>k<kept>
`roll <trait #> + <knack#> -> <t+k>k<t>
`roll/no - do not explode
`roll <roll> vs <target> -> No <target> assumes 15
`roll <roll> vs <player>:<trait> -> target = trait * 5

OBJECT NAMES:
	7sr: 7th Sea Stat Roller.
	7sss: 7th Sea Stat Setter.

i: input for roll
s: switches
p: people to show
v: versus

t: trait value
n: knack value
w: trait text ( may be value )
x: knack text ( may be value )
u: unkept
k: kept

g: someone else's trait/knack value
e: error
r: roll dice results ( first raw, then kept|unkept )

o: output, what we'll be showing
z: list of ze people we'll be showing it to


&c.roll 7sr=
$+roll*:@pemit %#=
	[setq( i, %0 )]

// >> SWITCHES
	[setq( s, 
		if( 
			strmatch( %qi, /* ), 
			[after( first( %qi ), / )][setq( i, rest( %qi ))]
		)
	)]

// >> PEOPLE WHO WANT TO SEE THIS FUN
	[setq( p, 
		if( 
			t( rest( %qi, = )), 
			[rest( %qi, = )] %#[setq( i, before( %qi, = ))][setq( q, private )], 
			[lcon( loc( %# ), connect )][[setq( q, public )]]
		)
	)]

// >> vs <target> | <player>:<trait> | 15 ( default )
	[setq( v, 
		if( 
			t( rest( %qi, vs )), 
			[rest( %qi, vs )][setq( i, before( %qi, vs ))], 
			15
		)
	)]
	[setq( v, 
		case( 
			1, 
			and( strmatch( %qv, *:* ), isint( rest( %qv, : ))), 
			mul( rest( %qv, : ), 5 ), 

			and( strmatch( %qv, *:* ), t( setr( g, u( f.value-trait-or-knack, trim( first( %qv, : )), trim( rest( %qv, : )))))), 
			[mul( first( %qg, : ), 5 )]
			[setq( b, [name( pmatch( trim( first( %qv, : ))))]'s [titlestr( last( %qg, . ))] )], 

			strmatch( %qv, *:* ), 
			0, 

			%qv
		)
	)]

// >> <trait> + <knack> | <unkept>k<kept>
	[case( 
		1, 

// .. <trait> + <knack>, value or not?
		strmatch( %qi, *+* ), 
		[setq( t, 
			case( 
				1, 
				isint( setr( t, trim( first( %qi, + )))), 
				%qt[setq( w, %qt )], 

				not( t( setr( t, u( f.value-trait-or-knack, %#, %qt )), : )), 
				0[setq( e, rest( %qt ))], 

				t( rest( %qt, : )), 
				[first( %qt, : )][setq( w, rest( %qt, : ))], 

				0[setq( e, Unknown Failure for Trait )]
			)
		)]
		[setq( n, 
			case( 
				1, 
				isint( setr( n, trim( rest( %qi, + )))), 
				%qn[setq( x, %qn )], 

				not( t( setr( n, u( f.value-trait-or-knack, %#, %qn )), : )), 
				0[setq( e, rest( %qn ))], 

				t( rest( %qn, : )), 
				[first( %qn, : )][setq( x, rest( %qn, : ))], 

				not( t( %qn )), 
				0[setq( e, rest( %qn ))], 

				0[setq( e, Unknown Failure for Knack )]
			)
		)]
		[setq( u, add( %qt, %qn ))][setq( k, %qt )], 

// .. <unkept>k<kept>, always numeric
		strmatch( %qi, *k* ), 
		[setq( u, first( %qi, k ))][setq( k, rest( %qi, k ))], 
		setq( e, Unknown format )
	)]

	[if( 
		gte( %qu, 10 ), 
		[setq( k, add( %qk, sub( %qu, 10 )))][setq( u, 10 )]
	)]
	[setq( k, min( %qu, %qk ))]

// >> ROLL
	[case( 
		1, 
		t( %qe ), 
		@@( error: don't even bother ), 
		t( match( %qs, no*, / )), 
		[setq( r, ulocal( f.roll.no-explode, %qu ))]
		[setq( q, %qq no-explode )], 
		or( t( match( %qs, 0*, / )), t( match( %qs, zero*, / ))), 
		[setq( r, ulocal( f.roll.zero, %qu ))]
		[setq( q, %qq zero-dice )], 
		setq( r, ulocal( f.roll.explode, %qu ))
	)]

	[setq( r, revwords( sort( %qr )))]

// >> COMPARE
	[case( 
		1, 
		t( %qe ), 
		@@( error: don't even bother ), 
		setq( r, 
			[extract( %qr, 1, %qk )]|
			[extract( %qr, inc( %qk ), words( %qr ))]
		)
	)]

// >> ANNOUNCE
	[case( 
		1, 
		t( %qe ), %qe, 
		[iter( 
			%qp, 
			[if( 
				pmatch( %i0 ), 
				setq( z, %qz [pmatch( %i0 )] )
			)], , @@
		)]
		[setq( z, setunion( %qz, ))]
		[pemit( %qz, u( f.output.roll ))]
	)]

---

&f.roll.no-explode  7sr=lrand( 1, 10, %0 )
&f.roll.explode  7sr=iter( lrand( 1, 10, %0 ), ulocal( f.roll.reroll-checker, %i0 ))
&f.roll.zero 7sr=lrand( 0, 9, %0 )
&f.roll.reroll-checker 7sr=ladd( %0 [if( eq( %0, 10 ), u( f.roll.reroll-checker, rand( 1, 10 )), 0 )] )

---

&f.output.roll 7sr=
	[header( 
		[name( %# )] Rolls:
		[if( 
			t( %qw ), 
			[if( isint( %qw ), %qw, titlestr( edit( last( %qw, . ), _, %b )))] +
			[if( isint( %qx ), %qx, titlestr( edit( last( %qx, . ), _, %b )))], 
			%qu k %qk
		)] vs [if( t( %qb ), %qb, %qv )]
	)]%r
	%b Roll: [first( %qr, | )] [if( rest( %qr, | ), ( [ansi( xh, rest( %qr, | ))] ))]%r
	%b [ladd( first( %qr, | ))] vs %qv :
	[if( 
		gte( ladd( first( %qr, | )), %qv ), 
		Success, 
		Failure
	)]%r
	[footer( iter( %qq, %i0, , %, b ))]

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==--

&c.roll 7sr=$+roll*:@pemit %#=[setq( i, %0 )][setq( s, if( strmatch( %qi, /* ), [after( first( %qi ), / )][setq( i, rest( %qi ))] ))][setq( p, if( t( rest( %qi, = )), [rest( %qi, = )] %#[setq( i, before( %qi, = ))][setq( q, private )], [lcon( loc( %# ), connect )][[setq( q, public )]] ))][setq( v, if( t( rest( %qi, vs )), [rest( %qi, vs )][setq( i, before( %qi, vs ))], 15 ))][setq( v, case( 1, and( strmatch( %qv, *:* ), isint( rest( %qv, : ))), mul( rest( %qv, : ), 5 ), and( strmatch( %qv, *:* ), t( setr( g, u( f.value-trait-or-knack, trim( first( %qv, : )), trim( rest( %qv, : )))))), [mul( first( %qg, : ), 5 )][setq( b, [name( pmatch( trim( first( %qv, : ))))]'s [titlestr( last( %qg, . ))] )], strmatch( %qv, *:* ), 0, %qv ))][case( 1, strmatch( %qi, *+* ), [setq( t, case( 1, isint( setr( t, trim( first( %qi, + )))), %qt[setq( w, %qt )], not( t( setr( t, u( f.value-trait-or-knack, %#, %qt )), : )), 0[setq( e, rest( %qt ))], t( rest( %qt, : )), [first( %qt, : )][setq( w, rest( %qt, : ))], 0[setq( e, Unknown Failure for Trait )] ))][setq( n, case( 1, isint( setr( n, trim( rest( %qi, + )))), %qn[setq( x, %qn )], not( t( setr( n, u( f.value-trait-or-knack, %#, %qn )), : )), 0[setq( e, rest( %qn ))], t( rest( %qn, : )), [first( %qn, : )][setq( x, rest( %qn, : ))], not( t( %qn )), 0[setq( e, rest( %qn ))], 0[setq( e, Unknown Failure for Knack )] ))][setq( u, add( %qt, %qn ))][setq( k, %qt )], strmatch( %qi, *k* ), [setq( u, first( %qi, k ))][setq( k, rest( %qi, k ))], setq( e, Unknown format ))][if( gte( %qu, 10 ), [setq( k, add( %qk, sub( %qu, 10 )))][setq( u, 10 )] )][setq( k, min( %qu, %qk ))][case( 1, t( %qe ), @@( error: don't even bother ), t( match( %qs, no*, / )), [setq( r, ulocal( f.roll.no-explode, %qu ))][setq( q, %qq no-explode )], or( t( match( %qs, 0*, / )), t( match( %qs, zero*, / ))), [setq( r, ulocal( f.roll.zero, %qu ))][setq( q, %qq zero-dice )], setq( r, ulocal( f.roll.explode, %qu )))][setq( r, revwords( sort( %qr )))][case( 1, t( %qe ), @@( error: don't even bother ), setq( r, [extract( %qr, 1, %qk )]|[extract( %qr, inc( %qk ), words( %qr ))] ))][case( 1, t( %qe ), %qe, [iter( %qp, [if( pmatch( %i0 ), setq( z, %qz [pmatch( %i0 )] ))], , @@ )][setq( z, setunion( %qz, ))][pemit( %qz, u( f.output.roll ))] )]

&f.roll.no-explode  7sr=lrand( 1, 10, %0 )
&f.roll.explode  7sr=iter( lrand( 1, 10, %0 ), ulocal( f.roll.reroll-checker, %i0 ))
&f.roll.zero 7sr=lrand( 0, 9, %0 )
&f.roll.reroll-checker 7sr=ladd( %0 [if( eq( %0, 10 ), u( f.roll.reroll-checker, rand( 1, 10 )), 0 )] )

&f.output.roll 7sr=[header( [name( %# )] Rolls: [if( t( %qw ), [if( isint( %qw ), %qw, titlestr( edit( last( %qw, . ), _, %b )))] + [if( isint( %qx ), %qx, titlestr( edit( last( %qx, . ), _, %b )))], %qu k %qk )] vs [if( t( %qb ), %qb, %qv )] )]%r%b Roll: [first( %qr, | )] [if( rest( %qr, | ), ( [ansi( xh, rest( %qr, | ))] ))]%r%b [ladd( first( %qr, | ))] vs %qv : [if( gte( ladd( first( %qr, | )), %qv ), Success, Failure )]%r[footer( iter( %qq, %i0, , %, b ))]


-=-=-=-=-=-=-=-=-=-=-=-=--=-=-==--=-==--=-=--=-=-=--=-=-=-=-=-=-=-=-=-=

@create 7SSS: 7th Sea Stat System

@fo me=&d.7sss 7sr=[num( 7sss )]
@fo me=&d.7sdd 7sss=[num( 7sdd )]

--

0: player
1: trait or knack
returns: 0:<error> or <value>:<statpath>

&f.value-trait-or-knack 7sr=
localize( 
	[setq( 1, edit( %1, %b, _ ))]
	[setq( s, u( [u( d.7sss )]/f.find.sheet, %0 ))]
	[setq( p, u( [u( d.7sss )]/f.find.sheet.trait-or-knack, %qs, %q1 ))]
	[case( 
		0, 
		t( %qs ), %qs, 
		t( %qp ), %qp, 
		[u( %qs/%qp )]:%qp
	)]
 )

---

&f.value-trait-or-knack 7sr=localize( [setq( 1, edit( %1, %b, _ ))][setq( s, u( [u( d.7sss )]/f.find.sheet, %0 ))][setq( p, u( [u( d.7sss )]/f.find.sheet.trait-or-knack, %qs, %q1 ))][case( 0, t( %qs ), %qs, t( %qp ), %qp, [u( %qs/%qp )]:%qp )] )


-=-=-=-=-=-=-=-=-=-=-=-==-=--=-=-=-=-=--==--=-=-==--==--==-=-=--=-=-=-==--==-


Trait + Knack, explode 10s locally
If dramatic wounds >= resolve, do not explode 10s
If dramatic wounds = 2x resolve, unconscious

<unkept> k <kept>

	If unkept > 10, take any over 10 and make them kept
	If unkept < kept, kept = unkept

&sheet.7s: <dbref>
&gm.7s: if GMing for 7th Sea


== NOTES ===============================

These seem to come into one of three forms:

Value: Just a straight-up value
	( Traits )

List: A list of straight-up values
	( )

Reference: A reference to other stats
	( Skills reference to knacks )

Knacks aren't listed in the DD because they're infered from all the parts.  This isn't a complete working system, this is a system that just gets to the play.

For Skills and Advantages, any text is an indicator that they exist.  For Skills, I'll be putting in the Basic/Advanced list.  For Advantages, I'll be putting in whatever the player wants there.


-=-=-=-=-=-=-=-=-=-=-=-=-=-==--=-==-=-=--=-=-=-=-=-=-=-=-==--=-=-=-=-=-=-=-==--=

Determining the stat path, again.  ( "Stat Path" means "how do I know what attribute name this is stored on?" )  This time around, we get to make a whole crapload of assumptions based on nothing much.  The old fashioned way.

There is no value validation unless otherwise specified.

The dbref of a sheet is always found via the &sheet.7s attribute on someone

-- "Item Location" Functions ---------------------------------------------------

\ Where's the Data Dictionary?

&d.7sdd 7sss=#Data-Dictionary
@fo me=@edit 7sss/d.*=#Data-Dictionary, [num( 7sdd )]

---

&f.find.sheet 7sss=
localize( 
	case( 1, 
		not( t( setr( p, pmatch( %0 )))), #-1 Player Not Found, 
		not( t( setr( l, u( %qp/_sheet.7s )))), #-1 Sheet Not Found, 
		%ql
	)
 )


&f.find.sheet 7sss=localize( case( 1, not( t( setr( p, pmatch( %0 )))), #-1 Player Not Found, not( t( setr( l, u( %qp/_sheet.7s )))), #-1 Sheet Not Found, %ql ))

-- Checkers --------------------------------------------------------------------

We'll just flag people simply with a single attribute. ( set it to anything )

&f.isgm? 7sss=t( u( %0/gm.7s ))

-- "Return Statpath" Functions -------------------------------------------------

\ &d.knacks.skill 7sss=ucstr( iter( lattr( [u( d.7sdd )]/skill.* ), iter( edit( u( [u( d.7sdd )]/%i0 ), |, . ), knack.skill.[edit( %i0, %b, _ )], . )))

\ &d.knacks.sorcery 7sss=ucstr( iter( edit( u( [u( d.7sdd )]/sorcery.heritage ), %b, _ ), iter( u( [u( d.7sdd )]/sorcery.%i0 ), knack.sorcery.[edit( %i0, %b, _ )], . ), . ))

\ &d.knacks.swordsman 7sss=ucstr( iter( u( [u( d.7sdd )]/swordsman.school ), iter( rest( u( [u( d.7sdd )]/swordsman.%i0 ), | ), knack.swordsman.[edit( %i0, %b, _ )], . ), . ))

\ this version should stop overflow
\ 0: pure text name of knack being searched for
\ ( if it isn't passed, list everything )


&d.knacks.skill 7sss=ucstr( iter( if( t( %0 ), grepi( [u( d.7sdd )], skill.*, %0 ), lattr( [u( d.7sdd )]/skill.* )), iter( edit( u( [u( d.7sdd )]/%i0 ), |, . ), knack.skill.[edit( %i0, %b, _ )], . )))

&d.knacks.sorcery 7sss=ucstr( iter( if( t( %0 ), setdiff( grepi( [u( d.7sdd )], sorcery.*, %0 ), lattr( [u( d.7sdd )]/sorcery.*.* )), setdiff( lattr( [u( d.7sdd )]/sorcery.* ), lattr( [u( d.7sdd )]/sorcery.*.* ))), iter( edit( u( [u( d.7sdd )]/%i0 ), |, . ), knack.sorcery.[edit( %i0, %b, _ )], . )))

&d.knacks.swordsman 7sss=ucstr( iter( if( t( %0 ), setdiff( grepi( [u( d.7sdd )], swordsman.*, %0 ), lattr( [u( d.7sdd )]/swordsman.*.* )), setdiff( lattr( [u( d.7sdd )]/swordsman.* ), lattr( [u( d.7sdd )]/swordsman.*.* ))), iter( edit( u( [u( d.7sdd )]/%i0 ), |, . ), knack.swordsman.[edit( %i0, %b, _ )], . )))



&d.knacks 7sss=setunion( [u( d.knacks.skill )] [u( d.knacks.sorcery )] [u( d.knacks.swordsman )], )

&d.skill 7sss=lattr( [u( d.7sdd )]/skill.* )

&d.swordsman 7sss=setdiff( lattr( [u( d.7sdd )]/swordsman.* ), [lattr( [u( d.7sdd )]/swordsman.*.* )] swordsman.school )

&d.sorcery 7sss=setdiff( lattr( [u( d.7sdd )]/sorcery.* ), [lattr( [u( d.7sdd )]/sorcery.*.* )] sorcery.heritage )

---

%0: knack name
0: knack name ucstr
( ucstr because unicode is case-sensitive in grab, and everywhere else )
k: knack, in graball( ) form
g: knack, in grepi( ) form ( no instance, spaces, very simple filter search )
i: instance ( if there is one )
r: matching knacks
s: the search


&f.find.dd.knack 7sss=
localize( 
	[setq( 0, edit( ucstr( %0 ), %b, _ ))]
	[setq( g, trim( before( edit( %0, _, %b ), %( )))]
// .. set up the search parameters
	[if( 
		strmatch( %q0, *( * )), 
		[setq( i, before( after( %q0, %( ), % )))]
		[setq( k, trim( before( %q0, %( ), r, _ ))]
		[setq( k, %qk*_( %qi* ))], 
		[setq( k, %q0* )]
	)]
// .. basic search
	[setq( r, 
		u( f.grabknacks, knack*.%qk, %qg )
	)]
// .. if nothing found, see if the knack is a ( * )
	[if( 
		and( not( %qr ), strmatch( %0, *( * ))), 
		setq( r, 
			u( f.grabknacks, knack*.[before( %qk, _%( )]_( \\* ))
		)
	)]
	[if( 
		strmatch( %q0, *( * )), 
		edit( %qr, ( * ), ( %qi )), 
		%qr
	)]
 )



&f.find.dd.knack 7sss=localize( [setq( 0, edit( ucstr( %0 ), %b, _ ))][setq( g, trim( before( edit( %0, _, %b ), %( )))][if( strmatch( %q0, *( * )), [setq( i, before( after( %q0, %( ), % )))][setq( k, trim( before( %q0, %( ), r, _ ))][setq( k, %qk*_( %qi* ))], [setq( k, %q0* )] )][setq( r, u( f.grabknacks, knack*.%qk, %qg ))][if( and( not( %qr ), strmatch( %0, *( * ))), setq( r, u( f.grabknacks, knack*.[before( %qk, _%( )]_( \\* ))))][if( strmatch( %q0, *( * )), edit( %qr, ( * ), ( %qi )), %qr )] )


think u( 7sss/f.find.dd.knack, PARRY_( FENCING ))
think u( 7sss/f.find.dd.knack, PARRY ( FENCING ))

think u( 7sss/f.find.dd.knack, FORM_( WOLF ))

think u( 7sss/f.find.dd.knack, fletch )


-- Support Function: Grabknacks ---------

%0: Search parameter.  i.e., knack*.<whatnot>
returns: All matching knacks

&f.grabknacks 7sss=setunion( [graball( u( d.knacks.skill, %1 ), %0 )] [graball( u( d.knacks.sorcery, %1 ), %0 )] [graball( u( d.knacks.swordsman, %1 ), %0 )], )


think u( 7sss/f.grabknacks, knack*.parry_( * ), parry )


-- Find DD Stat -----------------------------

%0: stat
0: STAT_UPPERCASE
( ucstr because unicode is case-sensitive in lattr )
k: knack version of stat ( untouched version )
i: instance of stat


&f.find.dd.stat 7sss=
localize( 
	[setq( 0, edit( ucstr( %0 ), %b, _ ))]
	[setq( k, %q0 )]

// .. handle instances
	[if( 
		strmatch( %q0, *( * )), 
		[setq( i, before( after( %q0, %( ), % )))]
		[setq( 0, edit( %q0, _%( %qi% ), *_%( % )))]
	)]

// .. cascaded search, from broad to narrow
	[setq( 3, lattr( [u( d.7sdd )]/*.*.%q0* ))]
	[setq( 2, setdiff( lattr( [u( d.7sdd )]/*.%q0* ), [lattr( [u( d.7sdd )]/*.%q0*.* )] %q3 ))]
	[setq( 1, setdiff( lattr( [u( d.7sdd )]/%q0* ), [lattr( [u( d.7sdd )]/%q0*.* )] %q2 %q1 ))]

// .. results
	[setq( r, 
		case( 
			1, 
			t( %q1 ), %q1, 
			t( %q2 ), %q2, 
			t( %q3 ), %q3, 
			t( setr( k, u( f.find.dd.knack, %qk ))), %qk, 
			#-1 Stat Not Found in Records
		)
	)]

// .. return, fixing the instance
	[edit( %qr, %( % ), %( %qi% ))]
 )


&f.find.dd.stat 7sss=localize( [setq( 0, edit( ucstr( %0 ), %b, _ ))][setq( k, %q0 )][if( strmatch( %q0, *( * )), [setq( i, before( after( %q0, %( ), % )))][setq( 0, edit( %q0, _%( %qi% ), *_%( % )))] )][setq( 3, lattr( [u( d.7sdd )]/*.*.%q0* ))][setq( 2, setdiff( lattr( [u( d.7sdd )]/*.%q0* ), [lattr( [u( d.7sdd )]/*.%q0*.* )] %q3 ))][setq( 1, setdiff( lattr( [u( d.7sdd )]/%q0* ), [lattr( [u( d.7sdd )]/%q0*.* )] %q2 %q1 ))][setq( r, case( 1, t( %q1 ), %q1, t( %q2 ), %q2, t( %q3 ), %q3, t( setr( k, u( f.find.dd.knack, %qk ))), %qk, #-1 Stat Not Found in Records ))][edit( %qr, %( % ), %( %qi% ))] )

think u( 7sss/f.find.dd.stat, fin )
think u( 7sss/f.find.dd.stat, martial.archer )
think u( 7sss/f.find.dd.stat, fletch )
think u( 7sss/f.find.dd.stat, memb )
think u( 7sss/f.find.dd.stat, memb_( explorer ))

think u( 7sss/f.find.dd.stat, parry_( fencing ))
think u( 7sss/f.find.dd.stat, parry ( fencing ))

think u( 7sss/f.find.dd.stat, parry )


--------------------------------------------------------------------------------
-- Find a stat on the sheet ----------------------------------------------------

0: sheet loc
1: stat ( even <type>.<stat> )
( ucstr because unicode is case-sensitive in lattr )

&f.find.sheet.stat 7sss=
localize( 
	[setq( u, ucstr( %1 ))]
	[setq( 3, lattr( %0/*.*.%1* ))]
	[setq( 2, setdiff( lattr( %0/*.%qu* ), [lattr( %0/*.%qu*.* )] %q3 ))]
	[setq( 1, setdiff( lattr( %0/%qu* ), [lattr( %0/%qu*.* )] %q2 %q3 ))]
	[case( 
		1, 
		t( %q1 ), %q1, 
		t( %q2 ), %q2, 
		t( %q3 ), %q3, 
		#-1 Stat Not Found on Sheet
	)]
 )


&f.find.sheet.stat 7sss=localize( [setq( u, ucstr( %1 ))][setq( 3, lattr( %0/*.*.%1* ))][setq( 2, setdiff( lattr( %0/*.%qu* ), [lattr( %0/*.%qu*.* )] %q3 ))][setq( 1, setdiff( lattr( %0/%qu* ), [lattr( %0/%qu*.* )] %q2 %q3 ))][case( 1, t( %q1 ), %q1, t( %q2 ), %q2, t( %q3 ), %q3, #-1 Stat Not Found on Sheet )] )


think u( 7sss/f.find.sheet.stat, #407, fletcher )
think u( 7sss/f.find.sheet.stat, #407, archer )


--------------------------------------------------------------------------------
-- Find a stat if it's a Trait or a Knack --------------------------------------

that's trait.<trait>, knack.civil|marital.<knack>, always found on sheet
0: sheet loc
1: stat
( ucstr because unicode is case-sensitive in lattr )

&f.find.sheet.trait-or-knack 7sss=
localize( 
	case( 
		1, 
		t( setr( f, lattr( %0/trait.[ucstr( %1 )]* ))), %qf, 
		t( setr( f, lattr( %0/knack.*.[ucstr( %1 )]* ))), %qf, 
		#-1 Stat Not Found as Trait or Knack on Sheet
	)
 )

---

&f.find.sheet.trait-or-knack 7sss=localize( case( 1, t( setr( f, lattr( %0/trait.%1* ))), %qf, t( setr( f, lattr( %0/knack.*.%1* ))), %qf, #-1 Stat Not Found as Trait or Knack on Sheet ))


think u( 7sss/f.find.sheet.trait-or-knack, #407, fletcher )


================================================================================
== "GetStat" Functions =========================================================

--------------------------------------------------------------------------------
-- About Stat: Stat Path + Stat Knacks -----------------------------------------

0: stat
returns: <statpath>:<whatever's on the dd>

&f.aboutstat 7sss=
localize( 
	case( 
		0, 
		t( setr( p, u( f.find.dd.stat, %0 ))), 
		%qp, 
		eq( words( %qp ), 1 ), 
		#-2 Multiple Matches: %qp, 
		%qp:[u( [u( d.7sdd )]/%qp )]
	)
 )


&f.aboutstat 7sss=localize( case( 0, t( setr( p, u( f.find.dd.stat, %0 ))), %qp, eq( words( %qp ), 1 ), #-2 Multiple Matches: %qp, %qp:[u( [u( d.7sdd )]/%qp )] ))


think u( 7sss/f.aboutstat, archer )
think u( 7sss/f.aboutstat, fletcher )

think u( 7sss/f.aboutstat, parry )


--------------------------------------------------------------------------------
-- Get a Stat  -----------------------------------------------------------------

0: player
1: stat
returns: <statpath>:<value>

&f.getstat 7sss=
localize( 
	case( 
		0, 
		t( setr( s, u( f.find.sheet, %0 ))), 
		%qs, 
		t( setr( p, u( f.find.sheet.stat, %qs, %1 ))), 
		%qp, 
		eq( words( %qp ), 1 ), 
		#-2 Multiple Matches, 
		%qp:[u( %qs/%qp )]
	)
 )


&f.getstat 7sss=localize( case( 0, t( setr( s, u( f.find.sheet, %0 ))), %qs, t( setr( p, u( f.find.sheet.stat, %qs, %1 ))), %qp, eq( words( %qp ), 1 ), #-2 Multiple Matches, %qp:[u( %qs/%qp )] ))


--------------------------------------------------------------------------------
-- A Sheet's Knacks ------------------------------------------------------------

0: player
1: stat
returns: <knack_name>:<value> <knack_name>:<value> <advanced_knack>:<value>
( you can always get a list of valid knacks buy using f.aboutstat )
a: aboutstat

works for skills only

a: aboutstat
p: player's sheet

&f.sheetknacks 7sss=
localize( 
	case( 
		0, 
		t( setr( a, u( f.aboutstat, %1 ))), %qa, 
		t( setr( p, u( f.find.sheet, %0 ))), %qp, 
		[ulocal( f.sheetknacks.workhorse, %qp, %qa )]
	)
 )


&f.sheetknacks 7sss=localize( case( 0, t( setr( a, u( f.aboutstat, %1 ))), %qa, t( setr( p, u( f.find.sheet, %0 ))), %qp, [ulocal( f.sheetknacks.workhorse, %qp, %qa )] ))


--------------------------------------------------------------------------------
-- A Sheet's Knacks, the workhorse function ------------------------------------

0: dbref for sheet
1: aboutstat

k: list.of.knacks - ucstr( ) due to utf-8
t: type of knack: skill, sorcery or swordsman
i: individual knack statpath
n: individual knack name

&f.sheetknacks.workhorse 7sss=
// .. just.the.knacks.ma'am
	[setq( k, ucstr( edit( edit( rest( %1, : ), |, . ), %b, _ )))]
// .. type
	[setq( t, first( %1, . ))]
// .. for each knack on the skill
	[iter( %qk, 
// .. .. grab those that match on the sheet
// .. .. ( instanced items with a * will match all on sheet )
		iter( 
			lattr( %0/knack.%qt.%i0 ), 
			[edit( titlestr( edit( last( %i0, . ), _, %b )), %b, _ )]:[u( %0/%i0 )]
		), .
	)]


&f.sheetknacks.workhorse 7sss=[setq( k, ucstr( edit( edit( rest( %1, : ), |, . ), %b, _ )))][setq( t, first( %1, . ))][iter( %qk, iter( lattr( %0/knack.%qt.%i0 ), [edit( titlestr( edit( last( %i0, . ), _, %b )), %b, _ )]:[u( %0/%i0 )] ), . )]


think u( 7sss/f.sheetknacks.workhorse, #422, u( 7sss/f.aboutstat, Leegstra ))


--------------------------------------------------------------------------------
-- Does a Stat include a certain Knack? ----------------------------------------

0: full.skill.path
  ( for use as a filter, list of attribiutes: skill.*.*, swordsman.<school>, sorcery.<heritage> )
1: knack ( name only )

&f.hasknack? 7sss=
	or( 
		t( match( first( u( [u( d.7sdd )]/%0 ), | ), edit( %1, _, %b ), . )), 
		t( match( rest( u( [u( d.7sdd )]/%0 ), | ), edit( %1, _, %b ), . ))
	)


&f.hasknack? 7sss=or( t( match( first( u( [u( d.7sdd )]/%0 ), | ), edit( %1, _, %b ), . )), t( match( rest( u( [u( d.7sdd )]/%0 ), | ), edit( %1, _, %b ), . )))


think u( 7sss/f.hasknack?, skill.martial.archer, fletcher )


================================================================================
== "Set Stat" Functions ========================================================

0: player
1: whole.stat.path
2: value to set

&f.setstatpath 7sss=
localize( 
	case( 
		0, 
		t( setr( s, u( f.find.sheet, %0 ))), 
		%qs, 
		hasattr( [u( d.7sdd )], %1 ), 
		#-1 Stat Path Does Not Exist, 
// .. ok
		[null( set( %qs, %1:%2 ))]
		%1:[u( %qs/%1 )]
	)
 )


&f.setstatpath 7sss=localize( case( 0, t( setr( s, u( f.find.sheet, %0 ))), %qs, hasattr( [u( d.7sdd )], %1 ), #-1 Stat Path Does Not Exist, [null( set( %qs, %1:%2 ))]%1:[u( %qs/%1 )] ))


---

0: player
1: stat
2: value to set

&f.setstat 7sss=
localize( 
	case( 
		0, 
		t( setr( s, u( f.find.sheet, %0 ))), 
		%qs, 
		t( setr( a, u( f.aboutstat, %1 ))), 
		%qa, 
// .. ok -- may want to do some things with that later
		[setq( p, first( %qa, : ))]
		[setq( a, rest( %qa, : ))]
		[null( set( %qs, %qp:%2 ))]
		%qp:[u( %qs/%qp )]
	)
 )


&f.setstat 7sss=localize( case( 0, t( setr( s, u( f.find.sheet, %0 ))), %qs, t( setr( a, u( f.aboutstat, %1 ))), %qa, [setq( p, first( %qa, : ))][setq( a, rest( %qa, : ))][null( set( %qs, %qp:%2 ))]%qp:[u( %qs/%qp )] ))


---

0: player
1: stat
2: value to set

&f.shiftstat 7sss=
localize( 
	case( 
		0, 
		t( setr( s, u( f.find.sheet, %0 ))), 
		%qs, 
		t( setr( p, u( f.find.dd.stat, %1 ))), 
		%qp, 
		eq( words( %qp ), 1 ), 
		#-2 Multiple Matches: %qp, 
		isint( %2 ), 
		#-1 Shift Must Be Numeric, 
		or( isint( setr( v, u( %qs/%qp ))), not( comp( %qv, ))), 
		#-1 Stat Shifted Must Be Numeric or Null, 
// .. ok
		[null( set( %qs, %qp:[add( %2, %qv )] ))]
		%qp:[u( %qs/%qp )]
	)
 )


&f.shiftstat 7sss=localize( case( 0, t( setr( s, u( f.find.sheet, %0 ))), %qs, t( setr( p, u( f.find.dd.stat, %1 ))), %qp, eq( words( %qp ), 1 ), #-2 Multiple Matches: %qp, isint( %2 ), #-1 Shift Must Be Numeric, or( isint( setr( v, u( %qs/%qp ))), not( comp( %qv, ))), #-1 Stat Shifted Must Be Numeric or Null, [null( set( %qs, %qp:[add( %2, %qv )] ))]%qp:[u( %qs/%qp )] ))


================================================================================
== Command to Set Stats ========================================================

1: Who -> p
2: What -> s ( ucstr due to utf-8 )
3: How -> o
4: Value -> v
qr: return from shiftstat, setstatpath, or setstat

---

&c.set 7sss=$\+set ( .+? )/( .+? )( [+\-=] )( .* ):@pemit %#=
if( 
	not( u( f.isgm?, %# )), 
	Error: You're not a 7th Seas GM!, 

	[setq( p, pmatch( trim( %1 )))]
	[setq( s, ucstr( edit( trim( %2 ), %b, _ )))]
	[setq( o, trim( %3 ))]
	[setq( v, trim( %4 ))]

	[setq( r, 
		case( 1, 
			t( match( + -, %qo )), u( f.shiftstat, %qp, %qs, %qo%qv ), 
			t( setr( r, u( f.setstatpath, %qp, %qs, %qv ))), %qr, 
			u( f.setstat, %qp, %qs, %qv )
		)
	)]

	[if( 
		not( t( %qr )), Error: [rest( %qr )], 
		Set [name( %qp )]'s
		[edit( edit( titlestr( edit( edit( first( %qr, : ), ., %b.%b ), _, %b )), %b.%b, . ), %b, _ )]
		to [u( [u( f.find.sheet, %qp )]/[first( %qr, : )] )]
	)]
 )

---


&c.set 7sss=$\+set ( .+? )/( .+? )( [+\-=] )( .* ):@pemit %#=if( not( u( f.isgm?, %# )), Error: You're not a 7th Seas GM!, [setq( p, pmatch( trim( %1 )))][setq( s, ucstr( edit( trim( %2 ), %b, _ )))][setq( o, trim( %3 ))][setq( v, trim( %4 ))][setq( r, case( 1, t( match( + -, %qo )), u( f.shiftstat, %qp, %qs, %qo%qv ), t( setr( r, u( f.setstatpath, %qp, %qs, %qv ))), %qr, u( f.setstat, %qp, %qs, %qv )))][if( not( t( %qr )), Error: [rest( %qr )], Set [name( %qp )]'s [edit( edit( titlestr( edit( edit( first( %qr, : ), ., %b.%b ), _, %b )), %b.%b, . ), %b, _ )] to [u( [u( f.find.sheet, %qp )]/[first( %qr, : )] )] )] )

@set 7sss/c.set=regexp


================================================================================
== About Stats =================================================================

&c.about 7sss=$+about *:@pemit %#=
	[setq( r, u( f.aboutstat, edit( %0, %b, _ )))]
	[setq( s, edit( first( %qr, : ), _, %b ))]
	[setq( a, rest( %qr, : ))]
	[if( 
		not( t( %qr )), Error: [rest( %qr )], 

		[setq( m, 
		)]

		[setq( m, 
			case( 1, 

// .. arcana
				strmatch( %qs, arcana.arcana ), 
				Arcana|If you represent a major arcana it would be one of these: [itemize( %qa, . )], 

				strmatch( %qs, arcana.* ), 
				[rest( %qs, . )] Arcana|If you have a [lcstr( rest( %qs, . ))] it would be one of these: [itemize( %qa, . )], 

// .. background
				strmatch( %qs, bio.background ), 
				Background|If you have a mysterious past it would be one of these: [itemize( %qa, . )], 

// .. nation
				strmatch( %qs, bio.nation ), 
				Nation|You're from one of these nations: [itemize( %qa, . )], 

// .. trait
				strmatch( %qs, trait.* ), 
				[extract( %qs, 2, 1, . )]|A trait%, numeric%, determines how many dice you keep after a roll., 

// .. sorcery
				strmatch( %qs, bio.heritage ), 
				Sorcerous Heritage|National types of sorcery you have: [itemize( %qa, . )], 

				strmatch( %qs, bio.sorcerous_blood ), 
				[edit( last( %qs, . ), _, %b )]|The nature of your sorcerous blood: [itemize( %qa, . )], 

				strmatch( %qs, sorcery.* ), 
				Knacks for [last( %qs, . )]|[itemize( %qa, . )]|( This stat itself can be set with any information you think is useful. ), 

// .. swordsman
				strmatch( %qs, bio.school ), 
				Swordsman School|Schools of swordsmanship you know: [itemize( %qa, . )], 

				strmatch( %qs, swordsman.* ), 
				Skills & Knacks for [last( %qs, . )]|Skills Learned: [itemize( first( %qa, | ), . )]|Swordsman Knacks: [itemize( rest( %qa, | ), . )]||( This stat itself can be set with any information you think is useful. ), 

// .. other "bio" stats
				strmatch( %qs, bio.* ), 
				[%qs]|A simple stat for keeping track of things., 

// .. skill
				strmatch( %qs, skill.* ), 
				[last( %qs, . )]: [itemize( get( v( d.7sdd )/tags.%qs ), ., & )] Skill|Basic Knacks: [itemize( first( %qa, | ), . )]|Advanced Knacks: [itemize( rest( %qa, | ), . )]|( This stat itself can be set with any information you think is useful. ), 

// .. knack ( check only skill, swordsman and sorcery )
				strmatch( %qs, knack.*.* ), 
				[last( %qs, . )]: [extract( %qs, 2, 1, . )] Knack|Knacks are set depending on the skills%, swordsman schools%, or sorcery heritages you have.|This one belongs to: [titlestr( itemize( iter( 

				filter( 
					f.hasknack?, 
					[u( d.skill )]
					[u( d.sorcery )] [u( d.swordsman )], , , 
					last( %qs, . )
				), 

				rest( %i0, . ), , | ), | ))]., 

// .. advantage
				strmatch( %qs, advantage.* ), 
				[rest( %qs, . )]|Cost: [first( %qa, | )]|[rest( %qa, | )], 

// .. wounds
				strmatch( %qs, wounds.flesh ), 
				Flesh Wounds|These wounds determine if you get a Dramatic wound and are erased at the end of a scene., 

				strmatch( %qs, wounds.dramatic ), 
				Dramatic Wounds|These wounds hurt. If you have as many as your Resolve trait you no longer re-roll tens. If you have as many as twice your Resolve you're unconscious., 

// .. random other
				Huh?|I'm so confused.
			)
		)]

// >> output
		[header( titlestr( edit( first( %qm, | ), _, %b )))]%r
		[iter( 
			rest( %qm, | ), 
// .. if <title>: <info>, make it pretty
			if( strmatch( %i0, *: * ), 

				[divider( before( %i0, : ))]%r
				[wrap( trim( rest( %i0, : )), 76, left, %b%b )], 

				wrap( %i0, 76, left, %b%b )
			), 
			|, 
			%r%r
		)]%r
		[footer( )]
	)]

---

&c.about 7sss=$+about *:@pemit %#=[setq( r, u( f.aboutstat, edit( %0, %b, _ )))][setq( s, edit( first( %qr, : ), _, %b ))][setq( a, rest( %qr, : ))][if( not( t( %qr )), Error: [rest( %qr )], [setq( m, )][setq( m, case( 1, strmatch( %qs, arcana.arcana ), Arcana|If you represent a major arcana it would be one of these: [itemize( %qa, . )], strmatch( %qs, arcana.* ), [rest( %qs, . )] Arcana|If you have a [lcstr( rest( %qs, . ))] it would be one of these: [itemize( %qa, . )], strmatch( %qs, bio.background ), Background|If you have a mysterious past it would be one of these: [itemize( %qa, . )], strmatch( %qs, bio.nation ), Nation|You're from one of these nations: [itemize( %qa, . )], strmatch( %qs, trait.* ), [extract( %qs, 2, 1, . )]|A trait%, numeric%, determines how many dice you keep after a roll., strmatch( %qs, bio.heritage ), Sorcerous Heritage|National types of sorcery you have: [itemize( %qa, . )], strmatch( %qs, bio.sorcerous_blood ), [edit( last( %qs, . ), _, %b )]|The nature of your sorcerous blood: [itemize( %qa, . )], trmatch( %qs, sorcery.* ), Knacks for [last( %qs, . )]|[itemize( %qa, . )]|( This stat itself can be set with any information you think is useful. ), strmatch( %qs, bio.school ), Swordsman School|Schools of swordsmanship you know: [itemize( %qa, . )], strmatch( %qs, swordsman.* ), Skills & Knacks for [last( %qs, . )]|Skills Learned: [itemize( first( %qa, | ), . )]|Swordsman Knacks: [itemize( rest( %qa, | ), . )]||( This stat itself can be set with any information you think is useful. ), strmatch( %qs, bio.* ), [%qs]|A simple stat for keeping track of things., strmatch( %qs, skill.* ), [last( %qs, . )]: [itemize( get( v( d.7sdd )/tags.%qs ), ., & )] Skill|Basic Knacks: [itemize( first( %qa, | ), . )]|Advanced Knacks: [itemize( rest( %qa, | ), . )]|( This stat itself can be set with any information you think is useful. ), strmatch( %qs, knack.*.* ), [last( %qs, . )]: [extract( %qs, 2, 1, . )] Knack|Knacks are set depending on the skills%, swordsman schools%, or sorcery heritages you have.|This one belongs to: [titlestr( itemize( iter( filter( f.hasknack?, [u( d.skill )] [u( d.sorcery )] [u( d.swordsman )], , , last( %qs, . )), rest( %i0, . ), , | ), | ))]., strmatch( %qs, advantage.* ), [rest( %qs, . )]|Cost: [first( %qa, | )]|[rest( %qa, | )], strmatch( %qs, wounds.flesh ), Flesh Wounds|These wounds determine if you get a Dramatic wound and are erased at the end of a scene., strmatch( %qs, wounds.dramatic ), Dramatic Wounds|These wounds hurt. If you have as many as your Resolve trait you no longer re-roll tens. If you have as many as twice your Resolve you're unconscious., Huh?|I'm so confused. ))][header( titlestr( edit( first( %qm, | ), _, %b )))]%r[iter( rest( %qm, | ), if( strmatch( %i0, *: * ), [divider( before( %i0, : ))]%r[wrap( trim( rest( %i0, : )), 76, left, %b%b )], wrap( %i0, 76, left, %b%b )), |, %r%r )]%r[footer( )] )]


== NOTES ======================================================================

Traits:
	Brawn
	Finesse
	Resolve
	Wits
	Panache

Main Motivation:
Greatest Love:
Greatest Fear:


100 points

1. Background
2. Sorcery.  20: 1/2 Blooded.  40 pts: Full & Twice-Blooded
3. Swordsman.  25: Schooled.  35: Another country's school.
4. Traits.  All at 1, max 3 starting, 8 pts
5. Advantages.  Variable
6. Skills/Knacks.  2pts per skill, 1pt per basic knack, 3pts per advanced, max 3
7. Backgrounds ( max 4pts ), Arcana ( 1 only ), Equipment, Reputation, Defensive Knacks, etc. etc. etc.


Avalon:
	Glamour
	Donovan
	+1 Resolve

Castille:
	No Sorcery
	Aldana
	+1 Finesse

Eisen:
	No Sorcery
	Eisenfaust
	+1 Brawn

Montaigne:
	Port√©
	Valroux
	+1 Panache

Ussura:
	Pyeryem
	No Swordsman
	+1 Resolve

Vendel:
	Laerdom
	Leegstra
	+1 Wits

Vodacce:
	Sorte
	Ambrogia
	+1 Wits

SKILLS:
Unless noted, buy a skill ( 2 pts ) and get all basic knacks at 1 for free

Civil Skills ( 2 pts to buy ):
	Artist
		( Start w/ one basic knack at 2, others at 0 )
		Basic: Composer, Drawing, Musician ( Instrument ), Sulpting, Singing, Writing
	Courtier
		Basic: Dancing, Etiquette, Fashion, Oratory
		Advanced: ( p. 114 )
	Criminal
		Basic: Gambling, Quack, Shadowing, Stealth
		Advanced: ( p. 114 )
	Doctor
		Basic: Diagnosis, First Aid, Quack
		Advanced: ( p. 114 )
	Hunter
		( Start w/ three basic knacks at 1, others at 0 )
		Basic: Fishing, Skinning, Stealth, Survival, Tracking, Trail Signs, Traps
		Advanced: ( p. 114 )
	Merchant
		( Start w/ one basic knack at 2, others at 0 )
		Basic: Barber, Blacksmith, Butcher, Calligrapher, Ceramics, Chandler, Cooking, Cooper, Dying, Embalmer, Fletcher, Furrier, Gardener, Glassblower, Innkeeper, Jenny, Jeweler, Masseur, Miller, Paper Maker, Potter, Sail Maker, Scribe, Seamstress, Spinner, Steward, Tailor, Vintner, Weaver
		Advanced: ( p. 114 )
	Performer
		Basic: Acting, Dancing, Oratory, Singing
		Advanced: ( p. 114 )
	Sailor
		Basic: Balance, Climbing, Knotwork, Rigging
		Advanced: ( p. 115 )
	Scholar
		Basic: History, Mathematics, Philosophy, Research
		Advanced: ( p. 115 )
	Servant
		Basic: Etiquette, Fashion, Menial Tasks, Unobtrusive
		Advanced: ( p. 115 )
	Spy
		Basic: Shadowing, Stealth
		Advanced: ( p. 115 )
	Streetwise
		Basic:
		Advanced: ( p. 115 )

Marital Skills ( 3 pts to buy ):
	Archer
		Basic: Attack ( Bow ), Fletcher
		Advanced: ( p. 116 )
	Athelete
		Basic: Climbing, Footwork, Sprinting, Throwing
		Advanced: ( p. 116 )
	Buckler
		Basic: Parry ( Buckler )
		Advanced: ( p. 116 )
	Commander
		Basic: Strategy, Tactics
		Advanced: ( p. 116 )
	Crowssbow
		Basic: Attack ( Crossbow ), Fletcher
		Advanced: ( p. 116 )
	Dirty Fighting
		Basic: Attack ( Dirty FIghting )
		Advanced: ( p. 116 )
	Fencing
		Basic: Attack ( Fencing ), Parry ( Fencing )
		Advanced: ( p. 116 )
	Firearms
		Basic: Attack ( Firearms )
		Advanced: ( p. 116 )
	Heavy Weapon
		Basic: Attack ( Heavy Weapon ), Parry ( Heavy Weapon )
		Advanced: ( p. 116 )
	Knife
		Basic: Attack ( Knife ), Parry ( Knife )
		Advanced: ( p. 116 )
	Panzerhand
		Basic: Attack ( Panzerhand ), Parry ( Panzerhand )
		Advanced: ( p. 116 )
	Polearm
		Basic: Attack ( Polearm ), Parry ( Polearm )
		Advanced: ( p. 116 )
	Pugilism
		Basic: Attack ( Pugilism ), Footwork, Jab
		Advanced: ( p. 116 )
	Rider
		Basic: Ride
		Advanced: ( p. 116 )
	Wrestling
		Basic: Grapple
		Advanced: ( p. 116 )

Without Training:
	No dice explode
	+5 to TN


BACKGROUNDS ( 1-3, 4 pts total )
	Amnesia
	Cursed
	Debt
	Defeated
	Fear
	Hunted
	Hunting
	Lost Love
	Mistaken Identity
	Nemesis
	Obligation
	Rivalry
	Romance
	True Identity
	Vendetta
	Vow

Benefit:
	2x worth as gain in XP when the background comes up


ARCANA ( may have only 1 )
	Virtues ( 10 pt cost )
		Spend a drama die
	Hubris ( 10 pt gain )
		GM spends a drama die to activate, you may counter

	( Page 119 )
*/
